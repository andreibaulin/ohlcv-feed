# IRON Guard — универсальный «предохранитель» от выдумок (спецификация)

Повелитель, это документирует **идею, архитектуру и механику** нашего «предохранителя», который делает так, чтобы **цифры/факты в ответах не могли появиться “из головы”**.  
Идея **универсальная**: подходит для прогнозов, ботов, отчётов, любых проектов, где LLM (или человек) может ошибиться/додумать.

---

## 1) Зачем это нужно (проблема)

LLM может:
- **смешивать источники** (например, «state» и «последнюю свечу»);
- **подтягивать старые значения** из контекста/памяти;
- **“достраивать” правдоподобные числа**, если источник недоступен;
- **ошибочно интерпретировать** структуру данных.

Текстовый протокол сам по себе не гарантирует правду: он не блокирует генерацию.  
Нужен **технический замок**, который делает ложь **невозможной по процессу**.

---

## 2) Цель IRON Guard (инварианты)

IRON Guard должен обеспечивать 3 жёстких инварианта:

1) **No-Data → No-Numbers**  
   Если нет валидных данных/доказательств — **в ответе не может быть цифр/фактов** (только “НЕТ ДАННЫХ” + ссылки).

2) **Single Source of Truth**  
   Вся “правда” берётся только из **одного артефакта**: `bundle/report`, который собран машиной.

3) **Fail-Closed**  
   Любая ошибка парсинга, несовпадение, недоступность, несовместимость схемы — **останавливает сборку** и **не публикует обновление**.  
   (Чтобы не было “обновилось, но с мусором”.)

---

## 3) Угроза/модель ошибок (threat model)

Что мы предотвращаем:
- “Правдоподобные” уровни/проценты без источника.
- Тихие рассинхроны между разными endpoint’ами.
- Ошибки из‑за изменения структуры данных.
- Ошибки при ручном копипасте/редактировании отчёта.

Что мы НЕ решаем:
- Если источник сам врёт/испорчен — Guard честно закрепит **эту** реальность (но отметит хэш и provenance).
- Если нужно аналитическое мнение без цифр — Guard не мешает, но цифры всё равно запрещены без proof.

---

## 4) Ключевая идея: “контракт + сборка + валидация”

IRON Guard состоит из 5 частей:

### A) Raw Snapshots (сырьё)
Сохраняем **сырьевые** источники, как есть:
- `state_latest.json` (TA/state)
- `deriv_mini_latest.json` (RAW деривативные метрики: premiumIndex/OI/OIhist/funding)
- при необходимости: `ohlcv_latest.txt/json` и т.п.

### B) Stable Contract (контракт извлечения фактов)
Файл типа:
- `iron/IRON_CONTRACT_CURRENT.json`

В контракте описывается:
- какие поля считаем “истиной”;
- где они лежат (JSON pointer / path);
- как формировать стандартизированные зоны/уровни (3S/3R);
- как трактовать “quality metrics”.

**Это единственная точка адаптации**, если поменяется “движок” или структура state.

### C) Builder (детерминированный сборщик)
Скрипт, который:
- читает snapshots,
- применяет contract,
- формирует стандартизированный `bundle` и `report`,
- пишет sha256, timestamps, флаги fallback.

### D) Verifier (независимая проверка)
Скрипт, который:
- заново пересчитывает sha256 источников,
- проверяет соответствие фактов JSON pointers,
- проверяет derived-метрики,
- проверяет целостность report (по хэшу).

### E) Publishing rule (правило публикации/использования)
- Если verify PASS → публикуем `bundle/report`.
- Если verify FAIL → **ничего не публикуем** (старое остаётся, нового нет).

---

## 5) Канонический артефакт: chat_bundle + chat_report

### 5.1) `chat_bundle_latest.json` (машинная истина)
Минимальный состав:

```json
{
  "meta": {
    "generated_utc": "2026-02-15T20:51:07Z",
    "source": {
      "state_url": "...",
      "deriv_url": "..."
    },
    "sha256": {
      "state": "…",
      "deriv_mini": "…",
      "bundle": "…",
      "report": "…"
    },
    "flags": {
      "fallback_used": false,
      "strict_mode": true
    }
  },
  "proof": [
    { "name": "BTC.price", "pointer": "/BTC/price", "value": 68286.63 },
    { "name": "BTC.W1.discount_band.low", "pointer": "/BTC/W1/discount_band/0", "value": 64825.96 }
  ],
  "facts": {
    "BTC": { "...": "..." },
    "ETH": { "...": "..." }
  },
  "views": {
    "BTC": { "levels_3s_3r": { "...": "..." } },
    "ETH": { "levels_3s_3r": { "...": "..." } }
  }
}
```

**Зачем `proof[]`:** это “витрина доказательств” для ключевых цифр — чтобы всегда было видно “цифра → pointer → значение”.

### 5.2) `chat_report_latest.md` (человеческий отчёт)
Это **готовый текст**, который ты (или я) используешь “как есть”:
- без ручных правок,
- без добавления цифр,
- только копипаст.

В начале отчёта обязательно: **IRON‑PROOF** (минимум 3 строки):
- `state.updated_utc`
- `sha256.state`
- `sha256.deriv_mini`
(+ по желанию `sha256.report`)

---

## 6) Механика “Fail‑Closed” (главный замок)

### Правило:
- **Если нет валидного bundle/report — цифры запрещены.**

На уровне CI/workflow:
- Builder может создать bundle,
- но Verifier должен подтвердить,
- иначе публикации нет.

На уровне LLM/чата:
- если `chat_report_latest.md` доступен → отвечать только им;
- если нет → “НЕТ ДАННЫХ” (без цифр).

Это убирает пространство для “случайной выдумки”.

---

## 7) Универсальность: как переживает смену движка

Смена движка обычно означает:
- поменялись имена полей,
- изменились разделы/структуры JSON,
- поменялась логика расчётов.

IRON Guard переживает это так:

1) Verifier падает (это хорошо).
2) Ты меняешь **только** `IRON_CONTRACT_CURRENT.json`:
   - обновляешь pointers,
   - меняешь mapping зон/уровней,
   - обновляешь required fields.
3) Builder/Verifier остаются прежними.

**Итого:** 90% изменений локализовано в одном файле (контракт).

---

## 8) Контракт (IRON_CONTRACT) — принцип

Контракт описывает:
- обязательные поля,
- откуда их брать,
- как собирать 3S/3R,
- какие правила кластеризации/фильтрации применяются,
- какие derived-поля допускаются (и как их считать).

Пример структуры (идея, не догма):

```json
{
  "version": "1.0",
  "required": {
    "btc_price": "/BTC/price",
    "eth_price": "/ETH/price",
    "btc_atr_d1": "/BTC/ATR/D1",
    "eth_atr_d1": "/ETH/ATR/D1"
  },
  "levels": {
    "BTC": {
      "S1": {"type":"band", "path":"/BTC/W1/discount_band", "role":"oper"},
      "S2": {"type":"band", "path":"/BTC/D1/support_entry", "role":"struct"},
      "S3": {"type":"line", "path":"/BTC/W1/range_low", "role":"last"},
      "R1": {"type":"band", "path":"/BTC/D1/resistance_entry", "role":"oper"},
      "R2": {"type":"band", "path":"/BTC/W1/premium_band", "role":"struct"},
      "R3": {"type":"line", "path":"/BTC/W1/range_high", "role":"last"}
    }
  },
  "quality": {
    "BTC.W1.discount_band": "/BTC/W1/discount_stats",
    "BTC.D1.support_entry": "/BTC/D1/support_stats"
  }
}
```

**Важно:** contract не “считает рынок”, он задаёт **что считать истинной витриной**.

---

## 9) Как внедрять в другие проекты (боты, программы, отчёты)

IRON Guard — это паттерн. Он переносится почти 1 в 1:

### 9.1) Для торгового бота
- Snapshots: рыночные данные (OHLCV), позиции, риск‑параметры, лимиты.
- Contract: какие поля считаются “официальными” (balance, position, pnl).
- Bundle: “снимок состояния бота” + proof (pointers).
- Verifier: проверка целостности + sanity checks.
- Правило: бот не торгует, если verify FAIL (fail‑closed).

### 9.2) Для генерации отчётов/аналитики
- Snapshots: входные CSV/JSON + версии.
- Bundle: финальные таблицы + provenance.
- Report: текст/markdown/HTML, который берётся как “готовый”.

### 9.3) Для любых LLM‑подсказок
- LLM читает **только report**, не “интерпретирует сырые данные”.
- Запрещаем цифры без proof.

---

## 10) Режимы строгости (рекомендовано)

### STRICT (по умолчанию, для трейдинга)
- Любая ошибка → FAIL → нет обновления.
- Нет bundle/report → “НЕТ ДАННЫХ”.

### SOFT (для не‑критичных задач)
- Можно допускать частичный bundle (например, без deriv), но тогда:
  - `flags.partial=true`
  - в report явно “частично, без X”
  - LLM обязана писать “НЕТ ДАННЫХ по X”
- Важно: soft всё равно **fail‑closed по цифрам**, просто разрешает “часть цифр” из валидной части.

---

## 11) Санити‑чеки (чтобы ловить странности)

Verifier может дополнительно проверять:
- диапазоны значений (price > 0, ATR > 0),
- монотонность timestamp (updated_utc не назад),
- отсутствие NaN/None в обязательных местах,
- что band.low <= band.high,
- что 3S/3R не “перекрываются нелепо” (по правилам контракта).

**Но:** санити‑чеки — это дополнение, основа всё равно sha256 + pointers.

---

## 12) Полный data‑flow (ASCII схема)

```
[Raw Sources] --> [Snapshots] --> [Builder + Contract] --> [Bundle + Report]
      |                 |                 |                   |
      |                 |                 v                   |
      |                 +-----------> [Verifier] <------------+
      |                                  |
      v                                  v
  (unchanged)                      PASS / FAIL
                                      |
                         PASS -> publish/update
                         FAIL -> keep old / stop
```

---

## 13) Что должен делать ассистент (правило для чата)

**Если видишь валидный `chat_report_latest.md`:**
- отвечай только его содержимым,
- не добавляй цифр,
- не “улучшай формулировки”, если это может поменять смысл цифр.

**Если отчёта нет или он невалиден:**
- пиши: **“НЕТ ДАННЫХ (IRON FAIL)”**
- прикладывай ссылки на источники
- предлагай конкретное действие: “проверь workflow/файл contract”.

---

## 14) Мини‑чеклист сопровождения (чтобы не потерялось)

- [ ] Все источники сохраняются как snapshots (RAW).
- [ ] Есть `IRON_CONTRACT_CURRENT.json` (одна точка адаптации).
- [ ] Builder создаёт bundle/report и sha256.
- [ ] Verifier проверяет pointers+sha256 и падает на несовпадении.
- [ ] Workflow fail‑closed: не публикует мусор.
- [ ] LLM использует только report, иначе “НЕТ ДАННЫХ”.

---

## 15) Нотация: как называть “предохранитель”

В документах можно использовать:
- **IRON Guard**
- **Truth‑Lock**
- **Fail‑Closed Provenance Layer**
- **Data‑to‑Text Contract Guard**

Суть одна: **правда = артефакт, проверенный хэшем и контрактом**.

---

## 16) Короткое резюме (в одну фразу)

**Мы не “просим не врать”, мы делаем так, чтобы цифры могли появиться только из валидированного артефакта; иначе их нет.**
